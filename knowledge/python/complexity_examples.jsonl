{"type":"complexity_example","language":"python","title":"flatten_nested_validation_with_guard_clauses","smell":"deep_nesting","before":"def process_order(order):\n    if order is not None:\n        if order.get('items'):\n            if order.get('user_id'):\n                total = sum(item['price'] for item in order['items'])\n                return {'ok': True, 'total': total}\n            else:\n                return {'ok': False, 'error': 'missing_user'}\n        else:\n            return {'ok': False, 'error': 'no_items'}\n    else:\n        return {'ok': False, 'error': 'no_order'}","after":"def process_order(order):\n    if order is None:\n        return {'ok': False, 'error': 'no_order'}\n    if not order.get('items'):\n        return {'ok': False, 'error': 'no_items'}\n    if not order.get('user_id'):\n        return {'ok': False, 'error': 'missing_user'}\n\n    total = sum(item['price'] for item in order['items'])\n    return {'ok': True, 'total': total}","notes":"Guard clauses reduce nesting while preserving outputs and branch behavior."}
{"type":"complexity_example","language":"python","title":"extract_complex_condition_predicate","smell":"complex_boolean_logic","before":"def can_publish(user, post):\n    if user and user.is_active and (user.is_admin or user.role == 'editor') and post and not post.is_archived:\n        return True\n    return False","after":"def _has_publish_role(user):\n    return user.is_admin or user.role == 'editor'\n\n\ndef can_publish(user, post):\n    if not user:\n        return False\n    if not user.is_active:\n        return False\n    if not _has_publish_role(user):\n        return False\n    if not post:\n        return False\n    if post.is_archived:\n        return False\n    return True","notes":"Extract named predicate and flatten conditions to reduce cognitive complexity."}
{"type":"complexity_example","language":"python","title":"split_function_by_responsibility","smell":"long_function_mixed_responsibilities","before":"def handle_user(data, db, logger):\n    if 'email' not in data:\n        raise ValueError('email required')\n    email = data['email'].strip().lower()\n    if '@' not in email:\n        raise ValueError('invalid email')\n    user = db.find_user_by_email(email)\n    if user is None:\n        user = db.create_user(email=email)\n        logger.info(f'created {email}')\n    else:\n        logger.info(f'exists {email}')\n    return {'email': user.email, 'id': user.id}","after":"def _validate_and_normalize_email(data):\n    if 'email' not in data:\n        raise ValueError('email required')\n    email = data['email'].strip().lower()\n    if '@' not in email:\n        raise ValueError('invalid email')\n    return email\n\n\ndef _get_or_create_user(email, db, logger):\n    user = db.find_user_by_email(email)\n    if user is None:\n        user = db.create_user(email=email)\n        logger.info(f'created {email}')\n        return user\n    logger.info(f'exists {email}')\n    return user\n\n\ndef handle_user(data, db, logger):\n    email = _validate_and_normalize_email(data)\n    user = _get_or_create_user(email, db, logger)\n    return {'email': user.email, 'id': user.id}","notes":"Separates validation and persistence while preserving logs and DB call order."}
{"type":"complexity_example","language":"python","title":"extract_inner_loop_logic","smell":"nested_loops_with_conditionals","before":"def collect_valid_pairs(users, groups):\n    result = []\n    for user in users:\n        for group in groups:\n            if not user.get('active'):\n                continue\n            if group.get('disabled'):\n                continue\n            if user['id'] in group.get('member_ids', []):\n                result.append((user['id'], group['id']))\n    return result","after":"def _is_valid_membership(user, group):\n    if not user.get('active'):\n        return False\n    if group.get('disabled'):\n        return False\n    return user['id'] in group.get('member_ids', [])\n\n\ndef collect_valid_pairs(users, groups):\n    result = []\n    for user in users:\n        for group in groups:\n            if _is_valid_membership(user, group):\n                result.append((user['id'], group['id']))\n    return result","notes":"Extracting inner loop predicate reduces complexity and preserves iteration order."}
{"type":"complexity_example","language":"python","title":"consolidate_repeated_error_branches","smell":"repeated_branch_logic","before":"def parse_age(value):\n    if value is None:\n        return {'ok': False, 'error': 'invalid_age'}\n    if value == '':\n        return {'ok': False, 'error': 'invalid_age'}\n    try:\n        age = int(value)\n    except ValueError:\n        return {'ok': False, 'error': 'invalid_age'}\n    if age < 0:\n        return {'ok': False, 'error': 'invalid_age'}\n    return {'ok': True, 'age': age}","after":"def _invalid_age_result():\n    return {'ok': False, 'error': 'invalid_age'}\n\n\ndef parse_age(value):\n    if value is None or value == '':\n        return _invalid_age_result()\n    try:\n        age = int(value)\n    except ValueError:\n        return _invalid_age_result()\n    if age < 0:\n        return _invalid_age_result()\n    return {'ok': True, 'age': age}","notes":"Reduces duplication and cognitive load without changing error contract."}